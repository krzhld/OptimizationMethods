#include "dual_problem.h"

using namespace std;

/*“ранспонирвоание и умножение на -1 матрицы дл€ сведени€ канонической задачи к двойственной*/
matrix_t TransformationMatrix(matrix_t matrix)
{
	column_t columnTransform;
	matrix_t transform;
	int n = size(matrix);
	int m = size(matrix[1]);
	columnTransform.resize(n);
	transform.resize(m);
	for (int k = 0; k < m;k++)
	{
		transform[k] = columnTransform;
	}
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			transform[j][i] = -matrix[i][j];
		}
	}
	return transform;
}

/*ѕолучение двойственной задачи */
general_problem_t getDualLinearProblem(general_problem_t &problem) 
{
	matrix_t A; 
	column_t b, c;
	int M1, N1;
	tie(A, b, c, M1, N1) = problem;
	// инциализаци€ двойственной матрицы и двойственных столбцов 
	matrix_t dualA; 
	column_t dualb, dualc;
	
	//получение матрицы A двойственной задачи 
	dualA = TransformationMatrix(A);

	//столбец b двойственной задачи  - это столбец c пр€мой задачи, где все значени€ берутс€ со знаком - 
	/*все элементы столбца нужно умножить на - 1, чтобы свести полученную двойственную задаче к общей задаче Ћѕ
	(получить нужный знак неравенства(>= ))*/
	dualb.resize(size(c));
	for (int i = 0; i < size(c); i++)
	{
		dualb[i] = -c[i];
	}

	//столбец c двойственной задачи - это столбец b пр€мой задачи
	dualc.resize(size(b));
	for (int j = 0; j < size(b); j++)
	{
		dualc[j] = b[j];
	}

	/*числа N1 и M1 - это количество переменных с ограничени€ми на знак
	и количество неравенств в системе ограничений соответственно*/
	int dualN1 = M1; 
	int dualM1 = N1;

	general_problem_t dualProblem = make_tuple(dualA, dualb, dualc, dualM1, dualN1);

	return dualProblem;
}

/*ѕроверка совпадени€ числа и одного из значений в сочетании*/
bool IsNumberInBasis(int number, comb_t comb, int combSize)
{
	for (int i = 0; i < combSize; i++)
	{
		if (number == comb[i])
			return true;
	}
	return false;
}

/*ѕоиск обратной матрицы методом √аусса*/
matrix_t InverseMatrix(matrix_t A)
{
	int n = size(A);

	column_t Ecolumn; // строка единичной матрицы
	Ecolumn.resize(n);

	matrix_t E; // инициализаци€ единичной матрицы
	E.resize(n);
	for (int i = 0; i < n; i++)
	{
		E[i] = Ecolumn;
	}

	double temp;
	for (int i = 0; i < n; i++)
	{
		E[i][i] = 1;
	}

	for (int k = 0; k < n; k++)
	{
		temp = A[k][k];

		for (int j = 0; j < n; j++)
		{
			A[k][j] /= temp;
			E[k][j] /= temp;
		}

		for (int i = k + 1; i < n; i++)
		{
			temp = A[i][k];

			for (int j = 0; j < n; j++)
			{
				A[i][j] -= A[k][j] * temp;
				E[i][j] -= E[k][j] * temp;
			}
		}
	}

	for (int k = n - 1; k > 0; k--)
	{
		for (int i = k - 1; i >= 0; i--)
		{
			temp = A[i][k];

			for (int j = 0; j < n; j++)
			{
				A[i][j] -= A[k][j] * temp;
				E[i][j] -= E[k][j] * temp;
			}
		}
	}

	//преобразованна€ единична€ матрица €вл€етс€ обратной матрицей к матрице ј 
	return E;
}

column_t MultipliedQuadMatrixAndColumn(matrix_t M, column_t c)
{
	int n = size(c);

	column_t X; ///результат перемножени€
	X.resize(n);

	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			X[i] += M[i][j] * c[j];
		}
	}

	return X;
}

/*¬осстановление решени€ двойственной задачи из решени€ пр€мой задачи*/
column_t SolvingDualProblem(canon_problem_t problem, column_t X, comb_t optBasis)
{
	matrix_t A; 
	column_t b, c;
	tie(A, b, c) = problem;

	int n = size(c);
	int m = size(b);

	column_t Y; // решение двойственной задачи 

	column_t columnBasis; // столбец базиса
	columnBasis.resize(m);

	matrix_t basis; //базис оптимального решени€ 
	basis.resize(m);

	for (int i = 0; i < m; i++)
	{
		basis[i] = columnBasis;
	}

	column_t cB; // вектор компонент целевой функцию, соответствующий базису оптимального решени€
	cB.resize(m);

	int numb = 0; //счетчик

	for (int i = 0; i < n; i++)
	{
		if (IsNumberInBasis(i + 1, optBasis, m))
		{
			for (int j = 0; j < m; j++)
			{
				basis[numb][j] = A[i][j];
			}
			cB[numb] = c[i];
			numb++;
		}
	}

	matrix_t invBasis = InverseMatrix(basis); // инвертируем матрицу базиса

	Y = MultipliedQuadMatrixAndColumn(invBasis, cB); 

	double result = 0;
	for (int i = 0; i < size(Y); i++)
	{
		result += Y[i] * b[i];
	}

	printf("\n %lf \n", result);

	return Y;

}
